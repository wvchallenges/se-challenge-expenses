{"version":3,"sources":["angular-chart.js"],"names":["factory","exports","module","angular","require","Chart","define","amd","Error","ChartJsProvider","options","responsive","ChartJs","getOptions","type","typeOptions","extend","this","setOptions","customOptions","merge","defaults","$get","ChartJsFactory","$timeout","createChart","scope","elem","getChartOptions","hasData","canDisplay","cvs","ctx","getContext","chartGetColor","getChartColorFn","data","getChartData","destroyChart","chart","$emit","bindEvents","canUpdateChart","newVal","oldVal","length","Array","isArray","every","element","index","reduce","sum","carry","val","getEventHandler","action","triggerOnlyOnChange","lastState","evt","atEvent","getElementsAtEvent","getPointsAtEvent","activePoints","call","equals","getColors","colors","copy","chartColors","global","notEnoughColors","chartData","push","map","convertColor","color","getColor","hexToRgb","substr","getRandomColor","getRandomInt","backgroundColor","rgba","pointBackgroundColor","pointHoverBackgroundColor","borderColor","pointBorderColor","pointHoverBorderColor","min","max","Math","floor","random","alpha","useExcanvas","join","concat","hex","bigint","parseInt","r","g","b","getDataSets","chartLabels","chartSeries","chartDatasetOverride","getData","labels","series","datasetOverride","datasets","item","i","dataset","label","hoverBackgroundColor","chartOptions","onclick","chartClick","noop","onmousemove","chartHover","updateChart","values","forEach","update","isEmpty","value","Object","keys","clientHeight","destroy","restrict","chartType","link","watchData","watchOther","watchType","window","G_vmlCanvasManager","initElement","$watch","$on","resize","multiTooltipTemplate","tooltips","mode","elements","line","borderWidth","rectangle","legend","display","animation","provider","directive","name"],"mappings":"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","file":"angular-chart.min.js","sourcesContent":["(function (factory) {\n  'use strict';\n  if (typeof exports === 'object') {\n    // Node/CommonJS\n    module.exports = factory(\n      typeof angular !== 'undefined' ? angular : require('angular'),\n      typeof Chart !== 'undefined' ? Chart : require('chart.js'));\n  }  else if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define(['angular', 'chart'], factory);\n  } else {\n    // Browser globals\n    if (typeof angular === 'undefined' || typeof Chart === 'undefined')\n      throw new Error('Chart.js library needs to be included, see http://jtblin.github.io/angular-chart.js/');\n    factory(angular, Chart);\n  }\n}(function (angular, Chart) {\n  'use strict';\n\n  Chart.defaults.global.multiTooltipTemplate = '<%if (datasetLabel){%><%=datasetLabel%>: <%}%><%= value %>';\n  Chart.defaults.global.tooltips.mode = 'label';\n  Chart.defaults.global.elements.line.borderWidth = 2;\n  Chart.defaults.global.elements.rectangle.borderWidth = 2;\n  Chart.defaults.global.legend.display = false;\n  Chart.defaults.global.colors = [\n    '#97BBCD', // blue\n    '#DCDCDC', // light grey\n    '#F7464A', // red\n    '#46BFBD', // green\n    '#FDB45C', // yellow\n    '#949FB1', // grey\n    '#4D5360'  // dark grey\n  ];\n\n  var useExcanvas = typeof window.G_vmlCanvasManager === 'object' &&\n    window.G_vmlCanvasManager !== null &&\n    typeof window.G_vmlCanvasManager.initElement === 'function';\n\n  if (useExcanvas) Chart.defaults.global.animation = false;\n\n  return angular.module('chart.js', [])\n    .provider('ChartJs', ChartJsProvider)\n    .factory('ChartJsFactory', ['ChartJs', '$timeout', ChartJsFactory])\n    .directive('chartBase', ['ChartJsFactory', function (ChartJsFactory) { return new ChartJsFactory(); }])\n    .directive('chartLine', ['ChartJsFactory', function (ChartJsFactory) { return new ChartJsFactory('line'); }])\n    .directive('chartBar', ['ChartJsFactory', function (ChartJsFactory) { return new ChartJsFactory('bar'); }])\n    .directive('chartHorizontalBar', ['ChartJsFactory', function (ChartJsFactory) { return new ChartJsFactory('horizontalBar'); }])\n    .directive('chartRadar', ['ChartJsFactory', function (ChartJsFactory) { return new ChartJsFactory('radar'); }])\n    .directive('chartDoughnut', ['ChartJsFactory', function (ChartJsFactory) { return new ChartJsFactory('doughnut'); }])\n    .directive('chartPie', ['ChartJsFactory', function (ChartJsFactory) { return new ChartJsFactory('pie'); }])\n    .directive('chartPolarArea', ['ChartJsFactory', function (ChartJsFactory) { return new ChartJsFactory('polarArea'); }])\n    .directive('chartBubble', ['ChartJsFactory', function (ChartJsFactory) { return new ChartJsFactory('bubble'); }])\n    .name;\n\n  /**\n   * Wrapper for chart.js\n   * Allows configuring chart js using the provider\n   *\n   * angular.module('myModule', ['chart.js']).config(function(ChartJsProvider) {\n   *   ChartJsProvider.setOptions({ responsive: false });\n   *   ChartJsProvider.setOptions('Line', { responsive: true });\n   * })))\n   */\n  function ChartJsProvider () {\n    var options = { responsive: true };\n    var ChartJs = {\n      Chart: Chart,\n      getOptions: function (type) {\n        var typeOptions = type && options[type] || {};\n        return angular.extend({}, options, typeOptions);\n      }\n    };\n\n    /**\n     * Allow to set global options during configuration\n     */\n    this.setOptions = function (type, customOptions) {\n      // If no type was specified set option for the global object\n      if (! customOptions) {\n        customOptions = type;\n        options = angular.merge(options, customOptions);\n      } else {\n        // Set options for the specific chart\n        options[type] = angular.merge(options[type] || {}, customOptions);\n      }\n\n      angular.merge(ChartJs.Chart.defaults, options);\n    };\n\n    this.$get = function () {\n      return ChartJs;\n    };\n  }\n\n  function ChartJsFactory (ChartJs, $timeout) {\n    return function chart (type) {\n      return {\n        restrict: 'CA',\n        scope: {\n          chartGetColor: '=?',\n          chartType: '=',\n          chartData: '=?',\n          chartLabels: '=?',\n          chartOptions: '=?',\n          chartSeries: '=?',\n          chartColors: '=?',\n          chartClick: '=?',\n          chartHover: '=?',\n          chartDatasetOverride: '=?'\n        },\n        link: function (scope, elem/*, attrs */) {\n          if (useExcanvas) window.G_vmlCanvasManager.initElement(elem[0]);\n\n          // Order of setting \"watch\" matter\n          scope.$watch('chartData', watchData, true);\n          scope.$watch('chartSeries', watchOther, true);\n          scope.$watch('chartLabels', watchOther, true);\n          scope.$watch('chartOptions', watchOther, true);\n          scope.$watch('chartColors', watchOther, true);\n          scope.$watch('chartDatasetOverride', watchOther, true);\n          scope.$watch('chartType', watchType, false);\n\n          scope.$on('$destroy', function () {\n            destroyChart(scope);\n          });\n\n          scope.$on('$resize', function () {\n            if (scope.chart) scope.chart.resize();\n          });\n\n          function watchData (newVal, oldVal) {\n            if (! newVal || ! newVal.length || (Array.isArray(newVal[0]) && ! newVal[0].length)) {\n              destroyChart(scope);\n              return;\n            }\n            var chartType = type || scope.chartType;\n            if (! chartType) return;\n\n            if (scope.chart && canUpdateChart(newVal, oldVal))\n              return updateChart(newVal, scope);\n\n            createChart(chartType, scope, elem);\n          }\n\n          function watchOther (newVal, oldVal) {\n            if (isEmpty(newVal)) return;\n            if (angular.equals(newVal, oldVal)) return;\n            var chartType = type || scope.chartType;\n            if (! chartType) return;\n\n            // chart.update() doesn't work for series and labels\n            // so we have to re-create the chart entirely\n            createChart(chartType, scope, elem);\n          }\n\n          function watchType (newVal, oldVal) {\n            if (isEmpty(newVal)) return;\n            if (angular.equals(newVal, oldVal)) return;\n            createChart(newVal, scope, elem);\n          }\n        }\n      };\n    };\n\n    function createChart (type, scope, elem) {\n      var options = getChartOptions(type, scope);\n      if (! hasData(scope) || ! canDisplay(type, scope, elem, options)) return;\n\n      var cvs = elem[0];\n      var ctx = cvs.getContext('2d');\n\n      scope.chartGetColor = getChartColorFn(scope);\n      var data = getChartData(type, scope);\n\n      // Destroy old chart if it exists to avoid ghost charts issue\n      // https://github.com/jtblin/angular-chart.js/issues/187\n      destroyChart(scope);\n\n      scope.chart = new ChartJs.Chart(ctx, {\n        type: type,\n        data: data,\n        options: options\n      });\n      scope.$emit('chart-create', scope.chart);\n      bindEvents(cvs, scope);\n    }\n\n    function canUpdateChart (newVal, oldVal) {\n      if (newVal && oldVal && newVal.length && oldVal.length) {\n        return Array.isArray(newVal[0]) ?\n        newVal.length === oldVal.length && newVal.every(function (element, index) {\n          return element.length === oldVal[index].length; }) :\n          oldVal.reduce(sum, 0) > 0 ? newVal.length === oldVal.length : false;\n      }\n      return false;\n    }\n\n    function sum (carry, val) {\n      return carry + val;\n    }\n\n    function getEventHandler (scope, action, triggerOnlyOnChange) {\n      var lastState = null;\n      return function (evt) {\n        var atEvent = scope.chart.getElementsAtEvent || scope.chart.getPointsAtEvent;\n        if (atEvent) {\n          var activePoints = atEvent.call(scope.chart, evt);\n          if (triggerOnlyOnChange === false || angular.equals(lastState, activePoints) === false) {\n            lastState = activePoints;\n            scope[action](activePoints, evt);\n          }\n        }\n      };\n    }\n\n    function getColors (type, scope) {\n      var colors = angular.copy(scope.chartColors ||\n        ChartJs.getOptions(type).chartColors ||\n        Chart.defaults.global.colors\n      );\n      var notEnoughColors = colors.length < scope.chartData.length;\n      while (colors.length < scope.chartData.length) {\n        colors.push(scope.chartGetColor());\n      }\n      // mutate colors in this case as we don't want\n      // the colors to change on each refresh\n      if (notEnoughColors) scope.chartColors = colors;\n      return colors.map(convertColor);\n    }\n\n    function convertColor (color) {\n      if (typeof color === 'object' && color !== null) return color;\n      if (typeof color === 'string' && color[0] === '#') return getColor(hexToRgb(color.substr(1)));\n      return getRandomColor();\n    }\n\n    function getRandomColor () {\n      var color = [getRandomInt(0, 255), getRandomInt(0, 255), getRandomInt(0, 255)];\n      return getColor(color);\n    }\n\n    function getColor (color) {\n      return {\n        backgroundColor: rgba(color, 0.2),\n        pointBackgroundColor: rgba(color, 1),\n        pointHoverBackgroundColor: rgba(color, 0.8),\n        borderColor: rgba(color, 1),\n        pointBorderColor: '#fff',\n        pointHoverBorderColor: rgba(color, 1)\n      };\n    }\n\n    function getRandomInt (min, max) {\n      return Math.floor(Math.random() * (max - min + 1)) + min;\n    }\n\n    function rgba (color, alpha) {\n      // rgba not supported by IE8\n      return useExcanvas ? 'rgb(' + color.join(',') + ')' : 'rgba(' + color.concat(alpha).join(',') + ')';\n    }\n\n    // Credit: http://stackoverflow.com/a/11508164/1190235\n    function hexToRgb (hex) {\n      var bigint = parseInt(hex, 16),\n        r = (bigint >> 16) & 255,\n        g = (bigint >> 8) & 255,\n        b = bigint & 255;\n\n      return [r, g, b];\n    }\n\n    function hasData (scope) {\n      return scope.chartData && scope.chartData.length;\n    }\n\n    function getChartColorFn (scope) {\n      return typeof scope.chartGetColor === 'function' ? scope.chartGetColor : getRandomColor;\n    }\n\n    function getChartData (type, scope) {\n      var colors = getColors(type, scope);\n      return Array.isArray(scope.chartData[0]) ?\n        getDataSets(scope.chartLabels, scope.chartData, scope.chartSeries || [], colors, scope.chartDatasetOverride) :\n        getData(scope.chartLabels, scope.chartData, colors, scope.chartDatasetOverride);\n    }\n\n    function getDataSets (labels, data, series, colors, datasetOverride) {\n      return {\n        labels: labels,\n        datasets: data.map(function (item, i) {\n          var dataset = angular.extend({}, colors[i], {\n            label: series[i],\n            data: item\n          });\n          if (datasetOverride && datasetOverride.length >= i) {\n            angular.merge(dataset, datasetOverride[i]);\n          }\n          return dataset;\n        })\n      };\n    }\n\n    function getData (labels, data, colors, datasetOverride) {\n      var dataset = {\n        labels: labels,\n        datasets: [{\n          data: data,\n          backgroundColor: colors.map(function (color) {\n            return color.pointBackgroundColor;\n          }),\n          hoverBackgroundColor: colors.map(function (color) {\n            return color.backgroundColor;\n          })\n        }]\n      };\n      if (datasetOverride) {\n        angular.merge(dataset.datasets[0], datasetOverride);\n      }\n      return dataset;\n    }\n\n    function getChartOptions (type, scope) {\n      return angular.extend({}, ChartJs.getOptions(type), scope.chartOptions);\n    }\n\n    function bindEvents (cvs, scope) {\n      cvs.onclick = scope.chartClick ? getEventHandler(scope, 'chartClick', false) : angular.noop;\n      cvs.onmousemove = scope.chartHover ? getEventHandler(scope, 'chartHover', true) : angular.noop;\n    }\n\n    function updateChart (values, scope) {\n      if (Array.isArray(scope.chartData[0])) {\n        scope.chart.data.datasets.forEach(function (dataset, i) {\n          dataset.data = values[i];\n        });\n      } else {\n        scope.chart.data.datasets[0].data = values;\n      }\n\n      scope.chart.update();\n      scope.$emit('chart-update', scope.chart);\n    }\n\n    function isEmpty (value) {\n      return ! value ||\n        (Array.isArray(value) && ! value.length) ||\n        (typeof value === 'object' && ! Object.keys(value).length);\n    }\n\n    function canDisplay (type, scope, elem, options) {\n      // TODO: check parent?\n      if (options.responsive && elem[0].clientHeight === 0) {\n        $timeout(function () {\n          createChart(type, scope, elem);\n        }, 50, false);\n        return false;\n      }\n      return true;\n    }\n\n    function destroyChart(scope) {\n      if(! scope.chart) return;\n      scope.chart.destroy();\n      scope.$emit('chart-destroy', scope.chart);\n    }\n  }\n}));\n"],"sourceRoot":"/source/"}